auth:
    - __path__ (path to your module dir)

modules:
    - __pillar__
    - __salt__
    - __opts__
    - __context__ ({'systemd.sd_booted': True})
    - __grains__

runners:
    - __pillar__
    - __salt__
    - __opts__
    - __grains__

returners:
    - __salt__
    - __opts__
    - __pillar__
    - __grains__

pillars:
    - __salt__ (modules)
    - __opts__
    - __pillar__
    - __grains__

# nothing
tops:
    - ['__builtins__', '__file__', 'subprocess', 'yaml', '__name__', '__package__', '__doc__']

outputters:
    - __opts__
    - __pillar__
    - __grains__

states:
    - __pillar__
    - __low__ (lowstate structure?)
    - __env__
    - __running__
    - __lowstate__
    - __salt__
    - __opts__
    - __grains__

log_handlers:
    - __path__

renderers:
    - __salt__ - Execution functions (i.e. __salt__['test.echo']('foo'))
    - __grains__ - Grains (i.e. __grains__['os'])
    - __pillar__ - Pillar data (i.e. __pillar__['foo'])
    - __opts__ - Minion configuration options
    - __env__ - The effective salt fileserver environment (i.e. base). Also referred to as a "saltenv". __env__ should not be modified in a pure python SLS file. To use a different environment, the environment should be set when executing the state. This can be done in a couple different ways:
        Using the saltenv argument on the salt CLI (i.e. salt '*' state.sls foo.bar.baz saltenv=env_name).
        By adding a saltenv argument to an individual state within the SLS file. In other words, adding a line like this to the state's data structure: {'saltenv': 'env_name'}
    - __sls__ - The SLS path of the file. For example, if the root of the base environment is /srv/salt, and the SLS file is /srv/salt/foo/bar/baz.sls, then __sls__ in that file will be foo.bar.baz.

grains:
    - __salt__
    - __opts__
    - __pillar__
    - __grains__








# TODO later


cloud:
    -

search:
    -     - ['__builtins__', 'salt', '__file__', '__package__', '__path__', '__name__', 'os', '__doc__']

# TODO
roster:
    -

# TODO
proxy:
    -
